const fs = require('fs');
const path = require('path');
const { promisify } = require('util');

const writeFile = promisify(fs.writeFile);
const unlink = promisify(fs.unlink);

const getVideoId = (url) => {
    const regex = /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/v\/)([^&\n?#]+)/;
    const match = url.match(regex);
    return match ? match[1] : null;
};

const getVideoDetails = async (videoId, apiKey) => {
    try {
        console.log('Fetching video details for:', videoId);
        
        const response = await fetch(
            `https://www.googleapis.com/youtube/v3/videos?id=${videoId}&key=${apiKey}&part=snippet,contentDetails`
        );

        if (!response.ok) {
            throw new Error(`YouTube API error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        console.log('Video API response:', JSON.stringify(data, null, 2));

        if (!data.items || data.items.length === 0) {
            throw new Error('Video not found or not accessible');
        }

        const video = data.items[0];
        return {
            title: video.snippet.title,
            description: video.snippet.description,
            duration: video.contentDetails.duration,
            channelTitle: video.snippet.channelTitle
        };

    } catch (error) {
        console.error('Failed to get video details:', error.message);
        throw error;
    }
};

const getCaptionsList = async (videoId, apiKey) => {
    try {
        console.log('Fetching captions list for:', videoId);
        
        const response = await fetch(
            `https://www.googleapis.com/youtube/v3/captions?videoId=${videoId}&key=${apiKey}&part=snippet`
        );

        if (!response.ok) {
            throw new Error(`Captions API error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        console.log('Captions list response:', JSON.stringify(data, null, 2));

        if (!data.items || data.items.length === 0) {
            throw new Error('No captions available for this video');
        }

        // Prefer English captions, then auto-generated, then any available
        const englishCaptions = data.items.find(item => 
            item.snippet.language === 'en' && item.snippet.trackKind === 'standard'
        );
        
        const autoGeneratedEnglish = data.items.find(item => 
            item.snippet.language === 'en' && item.snippet.trackKind === 'ASR'
        );
        
        const anyCaptions = data.items[0];

        const selectedCaption = englishCaptions || autoGeneratedEnglish || anyCaptions;
        
        console.log('Selected caption:', {
            id: selectedCaption.id,
            language: selectedCaption.snippet.language,
            trackKind: selectedCaption.snippet.trackKind,
            name: selectedCaption.snippet.name
        });

        return selectedCaption;

    } catch (error) {
        console.error('Failed to get captions list:', error.message);
        throw error;
    }
};

const downloadCaption = async (captionId, apiKey) => {
    try {
        console.log('Downloading caption:', captionId);
        
        const response = await fetch(
            `https://www.googleapis.com/youtube/v3/captions/${captionId}?key=${apiKey}&tfmt=srt`
        );

        if (!response.ok) {
            throw new Error(`Caption download error: ${response.status} ${response.statusText}`);
        }

        const captionText = await response.text();
        console.log('Caption text length:', captionText.length);
        console.log('Caption preview:', captionText.substring(0, 500) + '...');

        return captionText;

    } catch (error) {
        console.error('Failed to download caption:', error.message);
        throw error;
    }
};

const convertSrtToPlainText = (srtContent) => {
    try {
        // Remove SRT formatting and extract just the text
        const lines = srtContent.split('\n');
        const textLines = [];
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            
            // Skip empty lines, sequence numbers, and timestamps
            if (line === '' || /^\d+$/.test(line) || /^\d{2}:\d{2}:\d{2}/.test(line)) {
                continue;
            }
            
            // This is subtitle text
            textLines.push(line);
        }
        
        return textLines.join(' ').replace(/\s+/g, ' ').trim();
    } catch (error) {
        console.error('Error converting SRT to plain text:', error);
        return srtContent;
    }
};

exports.handler = async (event, context) => {
    const headers = {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type',
        'Access-Control-Allow-Methods': 'POST, OPTIONS'
    };

    if (event.httpMethod === 'OPTIONS') {
        return { statusCode: 204, headers };
    }

    if (event.httpMethod !== 'POST') {
        return {
            statusCode: 405,
            headers,
            body: JSON.stringify({ error: 'Method not allowed' })
        };
    }

    try {
        const { url } = JSON.parse(event.body);
        if (!url) {
            return {
                statusCode: 400,
                headers,
                body: JSON.stringify({ 
                    success: false, 
                    error: 'YouTube URL is required' 
                })
            };
        }

        const videoId = getVideoId(url);
        if (!videoId) {
            return {
                statusCode: 400,
                headers,
                body: JSON.stringify({ 
                    success: false, 
                    error: 'Invalid YouTube URL' 
                })
            };
        }

        // You'll need to set this in your Netlify environment variables
        const apiKey = process.env.YOUTUBE_API_KEY;
        if (!apiKey) {
            return {
                statusCode: 500,
                headers,
                body: JSON.stringify({ 
                    success: false, 
                    error: 'YouTube API key not configured' 
                })
            };
        }

        console.log('Processing video:', videoId);
        
        // Step 1: Get video details
        const videoDetails = await getVideoDetails(videoId, apiKey);
        console.log('Video details retrieved:', videoDetails.title);
        
        // Step 2: Get captions list
        const selectedCaption = await getCaptionsList(videoId, apiKey);
        
        // Step 3: Download the caption
        const captionContent = await downloadCaption(selectedCaption.id, apiKey);
        
        // Step 4: Convert to plain text
        const transcript = convertSrtToPlainText(captionContent);

        return {
            statusCode: 200,
            headers,
            body: JSON.stringify({
                success: true,
                transcript: transcript,
                videoId: videoId,
                title: videoDetails.title,
                channelTitle: videoDetails.channelTitle,
                captionLanguage: selectedCaption.snippet.language,
                captionType: selectedCaption.snippet.trackKind === 'ASR' ? 'auto-generated' : 'manual',
                transcriptLength: transcript.length,
                step: 'youtube-api-transcript'
            })
        };

    } catch (error) {
        console.error('Error:', error);
        
        let errorMessage = 'Failed to get transcript';
        let statusCode = 500;
        
        if (error.message.includes('not found')) {
            errorMessage = 'Video not found or not accessible';
            statusCode = 404;
        } else if (error.message.includes('No captions available')) {
            errorMessage = 'No captions/transcripts available for this video';
            statusCode = 404;
        } else if (error.message.includes('API error')) {
            errorMessage = 'YouTube API error - check your API key and quota';
            statusCode = 403;
        } else if (error.message.includes('API key not configured')) {
            errorMessage = 'YouTube API key not configured';
            statusCode = 500;
        }

        return {
            statusCode: statusCode,
            headers,
            body: JSON.stringify({ 
                success: false, 
                error: errorMessage,
                details: error.message
            })
        };
    }
}; 